This guide uses example code to demonstrate the information collected and generated by CodeAnalyzer. The output of CodeAnalyzer consists of a series of text lines, each of which represents a function call. Usually an output line describes information for a C/C++ statement. Each output line contains 10 or more fields, separated by '@'. The description of each field is as below.

# 0: binaryname - the name of the LLVM bit code file 
# 1: directory - the directory of the source file
# 2: filename - the name of the source file
# 3: line number - the line number of the statement in the source file
# 4: function name - the name of the function in which the statement exists; to uniquely identify static functions, CodeAnalyzer appends the name of a static function with the pathname of the source file in which the function is defined. 
# 5: line number (same as #3)
# 6: control dependency
# 7: callee name
# 8: key name - the key information passed to an API call or accessed directly via a struct variable 
# 9: access type
#       '0' - read, '1' - write, when call type is 1 or 2; It is used to label whether a function reads or writes a key information.
#       '-1' - function call, when call type is 0 or 1
#       '-2' - other, when call type is 3, 4, 5, etc.
# 10: call type '0' - non-API call, '1' - API call, '2' - direct access, '3' - dependency, '4' - FP definition, '5' - FP call, '7' - const return, '8' - return call, '11' - return NULL, '12' - checked call
#
# For certain function calls, one or more fields can follow the 10th field to describe the value of each argument of the function call and the type of each argument.

 
Function call
	access type: -1
	call type: 0 - non-API call, 1 - API call
	If there is a return statement, which returns a constant value, immediately following the function call, the call type is followed by information of the return statement including the line number of the return statement and the return value.

	Example code 1:
        	10: fp = fopen(dat_file, "rb");
        	11: if (fp == NULL) {

		// The statement at line 10 calls function fopen, whose real function name is \1_fopen in this case.

		update_data.bc@/Users/guest/Projects/Talos/tests@update_data.c@10@update_data@10@0@^A_fopen@@-1@0@'0'@"rb"@i8*@i8*

	Example code 2:
                16: printf("Error reading %s\n", dat_file);
                17: return -2;

		// The statement at line 16 calls function printf, and is followed by a return statement at line 17, which returns a constant of -2.
	Output:
		update_data.bc@/Users/guest/Projects/Talos/tests@update_data.c@16@update_data@16@11;1,15;0@printf@@-1@0,17,-2@@'0'@i8*@i8*

Function call via a function pointer
	It is common in large project to use function pointer. For example, to support binary modules that extend the functionality of the main program, often a module implements the extended functionality in one or more functions and the main program calls these functions via function pointers so that different modules can easily be supported in a uniform way. To keep track of this kind of function calls, CodeAnalyzer collect two kinds of information: 1. the assignment of a function pointer; 2. the function call that uses a function pointer.

	Assignment of a function pointer
	access type: -2
	call type: 4
 
	Example code:
		typedef int (*handler_func_type)(int a);

		typedef struct {
			…
        		handler_func_type handler;
		} handler_info_type;

		int my_handler(int a) {
        		…
		}

		handler_info_type handler_info = {
        		my_handler,
		};


	Output:
		main.bc@/Users/guest/Projects/Talos/tests@main.c@-1@*struct.handler_info_type,0@-1@@my_handler@@-2@4


	Function call via a function pointer
	access type: -2
	call type: 5

	Example code:
		34: data = handler_info.handler(data);

	Output:
		main.bc@/Users/guest/Projects/Talos/tests@main.c@34@update_data@34@25;1,29;1@*st
ruct.handler_info_type,0@@-2@5@@

Return call
	Sometimes a function calls another function and simply use the return value of the other function as its own return value. CodeAnalyzer also collects information for this special type of function calls.
	access type: -2
	call type: 8

	Example code:
		6:  int my_power(int a, int n) {
        	7:  	if (n == 0)
                8:		return 1;
        	9:  	else
                10:		return a * my_power(a, n - 1);
		11: }
		12:
		13: int my_handler(int a) {
		14:        return my_power(a, 2);
		15: }	
	
	Output:
		main.bc@/Users/guest/Projects/Talos/tests@main.c@14@my_handler@14@0@my_power@@-2@8 

Control dependency
	access type: -2
	call type: 3

	Example code:
        	11: if (fp == NULL) {
                12:	printf("Error openning %s\n", dat_file);
                13:	return -1;
        	14: }
        	15: if (fread(&data, sizeof(data), 1, fp) != 1) {
              	16:	printf("Error reading %s\n", dat_file);
               	17:	return -2;
        	18: }
        	19: fclose(fp);
        	20: outfile = getenv("OUTFILE");

		// The statement at line 20 is control dependent on both the statement at line 11 and the statement at 15. And line 20 will be executed only when both the condition at line 11 and line 15 are false.
	Output:
		update_data.bc@/Users/guest/Projects/Talos/tests@update_data.c@20@update_data@20@11;1,15;1@@@-2@3		

Return a constant value
	access type: -2
	call type: 7
	key name: return value

	Example code:
		17:	return -2;

		// The statement at line 17 returns constant -2.
	Output:
		update_data.bc@/Users/guest/Projects/Talos/tests@update_data.c@17@update_data@17
@11;1,15;0@@-2@-2@7

Check the return value of a function call
	access type: -2
	call type: 12
	key name: constant value, predicate

	Example code:
        	20: outfile = getenv("OUTFILE");
        	21: if (outfile) {
              	22:	fp = fopen(outfile, "w");

		// The statement at line 21 checks the return value of the call to function getenv against NULL

	Output:
		update_data.bc@/Users/guest/Projects/Talos/tests@update_data.c@21@update_data@21@@getenv@NULL,!=@-2@12

